/* ========================================
   SUB Language - x86-64 Native Code Generator
   Implementation
   File: codegen_x64.c
   ======================================== */

#define _GNU_SOURCE
#include "codegen_x64.h"
#include "windows_compat.h"
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

static const char* arg_registers_64[] = {"rdi", "rsi", "rdx", "rcx", "r8", "r9"};

/* Create code generation context */
X64Context* x64_context_create(FILE *output) {
    X64Context *ctx = calloc(1, sizeof(X64Context));
    ctx->output = output;
    ctx->label_counter = 0;
    return ctx;
}

void x64_context_free(X64Context *ctx) {
    free(ctx);
}

void x64_emit(X64Context *ctx, const char *format, ...) {
    va_list args;
    va_start(args, format);
    fprintf(ctx->output, "    ");
    vfprintf(ctx->output, format, args);
    fprintf(ctx->output, "\n");
    va_end(args);
}

void x64_emit_comment(X64Context *ctx, const char *comment) {
    fprintf(ctx->output, "    # %s\n", comment);
}

void x64_emit_label(X64Context *ctx, const char *label) {
    fprintf(ctx->output, "%s:\n", label);
}

/* Generate program prologue */
static void x64_generate_prologue(X64Context *ctx, IRModule *module) {
    fprintf(ctx->output, "# Generated by SUB Native Compiler\n");
    fprintf(ctx->output, ".intel_syntax noprefix\n\n");
    
    fprintf(ctx->output, ".section .rodata\n");
    // Format string for integers
    fprintf(ctx->output, ".LC_INT:\n");
    fprintf(ctx->output, "    .string \"%ld\\n\"\n");
    // Format string for strings
    fprintf(ctx->output, ".LC_STR:\n");
    fprintf(ctx->output, "    .string \"%s\\n\"\n");

    // All other string literals from the module
    for (int i = 0; i < module->string_count; i++) {
        fprintf(ctx->output, ".LC%d:\n", i);
        fprintf(ctx->output, "    .string \"%s\"\n", module->string_literals[i]);
    }
    
    fprintf(ctx->output, "\n.text\n");
    fprintf(ctx->output, ".global main\n\n");
}

/* Generate function prologue */
static void x64_generate_function_prologue(X64Context *ctx, IRFunction *func) {
    x64_emit_label(ctx, func->name);
    x64_emit_comment(ctx, "Function prologue");
    x64_emit(ctx, "push rbp");
    x64_emit(ctx, "mov rbp, rsp");
    
    // Allocate stack space for all local variables
    int total_stack = func->local_count * 8;
    if (total_stack > 0) {
        total_stack = (total_stack + 15) & ~15; // Align to 16 bytes
        x64_emit(ctx, "sub rsp, %d", total_stack);
    }
    
    // Move arguments from registers to their stack slots
    for (int i = 0; i < func->param_count; i++) {
        if (i < 6) { // Only handle up to 6 register arguments for now
            // Find the symbol for the i-th parameter
            Symbol *sym = func->sym_table->head;
            for(int j = 0; j < i && sym != NULL; ++j) sym = sym->next;

            if (sym) {
                 x64_emit(ctx, "mov [rbp - %d], %s", -sym->stack_offset, arg_registers_64[i]);
            }
        }
    }
}

/* Generate function epilogue */
static void x64_generate_function_epilogue(X64Context *ctx, IRFunction *func) {
    char return_label[256];
    snprintf(return_label, sizeof(return_label), ".L_ret_%s", func->name);
    x64_emit_label(ctx, return_label);
    
    x64_emit_comment(ctx, "Function epilogue");
    x64_emit(ctx, "mov rsp, rbp");
    x64_emit(ctx, "pop rbp");
    x64_emit(ctx, "ret\n");
}

/* Generate instruction */
void x64_generate_instruction(X64Context *ctx, IRInstruction *instr) {
    if (!instr) return;
    
    switch (instr->opcode) {
        case IR_CONST_INT:
            if (instr->src1->kind == IR_VAL_LABEL) { // It's a string literal
                x64_emit(ctx, "lea rax, %s[rip]", instr->src1->data.label);
            } else { // It's an integer
                x64_emit(ctx, "mov rax, %ld", instr->src1->data.int_val);
            }
            break;
            
        case IR_PUSH:
             x64_emit(ctx, "push rax");
             break;

        case IR_ADD:
            x64_emit(ctx, "pop rbx");
            x64_emit(ctx, "add rax, rbx");
            break;
            
        case IR_SUB:
            x64_emit(ctx, "mov rbx, rax");
            x64_emit(ctx, "pop rax");
            x64_emit(ctx, "sub rax, rbx");
            break;
            
        case IR_MUL:
            x64_emit(ctx, "pop rbx");
            x64_emit(ctx, "imul rax, rbx");
            break;
            
        case IR_DIV:
            x64_emit(ctx, "mov rbx, rax");
            x64_emit(ctx, "pop rax");
            x64_emit(ctx, "cqo"); // Sign-extend RAX into RDX:RAX
            x64_emit(ctx, "idiv rbx");
            break;
            
        case IR_RETURN:
            // The value to be returned is already in RAX from the previous expression
            if (instr->comment) {
                char return_label[256];
                snprintf(return_label, sizeof(return_label), ".L_ret_%s", instr->comment);
                x64_emit(ctx, "jmp %s", return_label);
            } else {
                x64_emit(ctx, "jmp .L_ret_main"); // Default
            }
            break;

        case IR_ALLOC:
            // No-op, stack space is allocated in the prologue
            break;
            
        case IR_STORE:
            // Value to store is in RAX. Destination is a stack offset.
            x64_emit(ctx, "mov [rbp - %lld], rax", -instr->dest->data.int_val);
            break;
            
        case IR_LOAD:
            // Source is a stack offset. Load value into RAX.
            x64_emit(ctx, "mov rax, [rbp - %lld]", -instr->src1->data.int_val);
            break;
            
        case IR_PRINT:
            x64_emit_comment(ctx, "Print value");
            x64_emit(ctx, "mov rsi, rax"); // Argument to print
            if (instr->src2 && instr->src2->data.int_val == IR_TYPE_STRING) {
                x64_emit(ctx, "lea rdi, .LC_STR[rip]");
            } else {
                x64_emit(ctx, "lea rdi, .LC_INT[rip]");
            }
            x64_emit(ctx, "xor rax, rax"); // No vector args
            x64_emit(ctx, "call printf@PLT");
            break;
            
        case IR_JUMP_IF_NOT:
            x64_emit(ctx, "cmp rax, 0");
            x64_emit(ctx, "je %s", instr->dest->data.label);
            break;

        case IR_EQ: case IR_NE: case IR_LT: case IR_LE: case IR_GT: case IR_GE:
            x64_emit(ctx, "pop rbx");
            x64_emit(ctx, "cmp rbx, rax"); // Compare left (popped) vs right (in rax)
            x64_emit(ctx, "mov rax, 0");    // Default to false
            const char *set_instr = "sete";
            switch(instr->opcode) {
                case IR_EQ: set_instr = "sete"; break;
                case IR_NE: set_instr = "setne"; break;
                case IR_LT: set_instr = "setl"; break;
                case IR_LE: set_instr = "setle"; break;
                case IR_GT: set_instr = "setg"; break;
                case IR_GE: set_instr = "setge"; break;
                default: break;
            }
            x64_emit(ctx, "%s al", set_instr);
            break;
            
        case IR_LABEL:
            x64_emit_label(ctx, instr->dest->data.label);
            break;
            
        case IR_JUMP:
            x64_emit(ctx, "jmp %s", instr->dest->data.label);
            break;
            
        case IR_CALL: {
            x64_emit_comment(ctx, "Function call");
            int arg_count = instr->src1 ? (int)instr->src1->data.int_val : 0;
            
            // Arguments were pushed to stack. Pop them into registers per ABI.
            for (int i = 0; i < arg_count && i < 6; i++) {
                x64_emit(ctx, "pop %s", arg_registers_64[i]);
            }
            
            // Align stack if needed (must be 16-byte aligned before call)
            x64_emit(ctx, "sub rsp, 8"); // Align stack
            x64_emit(ctx, "and rsp, -16");
            x64_emit(ctx, "add rsp, 8");

            x64_emit(ctx, "xor rax, rax");
            x64_emit(ctx, "call %s", instr->dest->data.label);
            
            // Cleanup stack space used for arguments if they were > 6 (not handled yet)
            // The pops already cleaned the stack for the first 6 args.
            break;
        }
            
        default:
            x64_emit_comment(ctx, "Unimplemented opcode");
            break;
    }
}

/* Generate function */
void x64_generate_function(X64Context *ctx, IRFunction *func) {
    if (!func) return;
    
    ctx->current_func = func;
    x64_generate_function_prologue(ctx, func);
    
    for (IRInstruction *instr = func->instructions; instr; instr = instr->next) {
        x64_generate_instruction(ctx, instr);
    }
    
    x64_generate_function_epilogue(ctx, func);
}

/* Generate complete program */
void x64_generate_program(X64Context *ctx, IRModule *module) {
    if (!module) return;
    
    x64_generate_prologue(ctx, module);
    
    for (IRFunction *func = module->functions; func; func = func->next) {
        x64_generate_function(ctx, func);
    }
}
