/* ========================================
   SUB Language - x86-64 Native Code Generator
   Implementation
   File: codegen_x64.c
   ======================================== */

#define _GNU_SOURCE
#include "codegen_x64.h"
#include "windows_compat.h"
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

/* Register names for AT&T syntax (GCC/Clang) */
static const char* register_names_64[] = {
    "rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp", "rsp",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
};

static const char* register_names_32[] = {
    "eax", "ebx", "ecx", "edx", "esi", "edi", "ebp", "esp",
    "r8d", "r9d", "r10d", "r11d", "r12d", "r13d", "r14d", "r15d"
};

/* Create code generation context */
X64Context* x64_context_create(FILE *output) {
    X64Context *ctx = calloc(1, sizeof(X64Context));
    ctx->output = output;
    ctx->label_counter = 0;
    ctx->string_counter = 0;
    ctx->stack_offset = 0;
    
    // Mark special registers as in use
    ctx->reg_in_use[X64_REG_RSP] = true;
    ctx->reg_in_use[X64_REG_RBP] = true;
    
    return ctx;
}

void x64_context_free(X64Context *ctx) {
    free(ctx);
}

/* Get register name */
const char* x64_register_name(X64Register reg, bool is_64bit) {
    if (reg >= X64_REG_COUNT) return "INVALID";
    return is_64bit ? register_names_64[reg] : register_names_32[reg];
}

/* Allocate a free register */
X64Register x64_alloc_register(X64Context *ctx) {
    // Prefer caller-saved registers first
    X64Register priority[] = {X64_REG_RAX, X64_REG_RCX, X64_REG_RDX, X64_REG_RSI, X64_REG_RDI, 
                               X64_REG_R8, X64_REG_R9, X64_REG_R10, X64_REG_R11};
    
    for (int i = 0; i < 9; i++) {
        if (!ctx->reg_in_use[priority[i]]) {
            ctx->reg_in_use[priority[i]] = true;
            return priority[i];
        }
    }
    
    // Fall back to callee-saved registers
    for (int i = X64_REG_RBX; i < X64_REG_COUNT; i++) {
        if (!ctx->reg_in_use[i]) {
            ctx->reg_in_use[i] = true;
            return i;
        }
    }
    
    return X64_REG_RAX; // Fallback
}

void x64_free_register(X64Context *ctx, X64Register reg) {
    if (reg != X64_REG_RSP && reg != X64_REG_RBP) {
        ctx->reg_in_use[reg] = false;
    }
}

int x64_generate_label(X64Context *ctx) {
    return ctx->label_counter++;
}

/* Emit assembly code */
void x64_emit(X64Context *ctx, const char *format, ...) {
    va_list args;
    va_start(args, format);
    fprintf(ctx->output, "    ");
    vfprintf(ctx->output, format, args);
    fprintf(ctx->output, "\n");
    va_end(args);
}

void x64_emit_comment(X64Context *ctx, const char *comment) {
    fprintf(ctx->output, "    # %s\n", comment);
}

void x64_emit_label(X64Context *ctx, const char *label) {
    fprintf(ctx->output, "%s:\n", label);
}

/* Generate program prologue */
static void x64_generate_prologue(X64Context *ctx) {
    fprintf(ctx->output, "# Generated by SUB Native Compiler\n");
    fprintf(ctx->output, "# Architecture: x86-64\n\n");
    
    fprintf(ctx->output, ".section .rodata\n");
    fprintf(ctx->output, ".section .data\n");
    fprintf(ctx->output, ".section .text\n");
    fprintf(ctx->output, ".global main\n\n");
}

/* Generate function prologue */
static void x64_generate_function_prologue(X64Context *ctx, IRFunction *func) {
    x64_emit_label(ctx, func->name);
    x64_emit_comment(ctx, "Function prologue");
    x64_emit(ctx, "pushq %%rbp");
    x64_emit(ctx, "movq %%rsp, %%rbp");
    
    // Allocate stack space for locals if needed
    if (func->local_count > 0) {
        int stack_size = func->local_count * 8;
        stack_size = (stack_size + 15) & ~15; // Align to 16 bytes
        x64_emit(ctx, "subq $%d, %%rsp", stack_size);
    }
}

/* Generate function epilogue */
static void x64_generate_function_epilogue(X64Context *ctx, IRFunction *func) {
    x64_emit_comment(ctx, "Function epilogue");
    
    // Create unique return label (e.g., "main_return:" instead of "main:")
    char return_label[256];
    snprintf(return_label, sizeof(return_label), "%s_return", func->name);
    x64_emit_label(ctx, return_label);
    
    x64_emit(ctx, "movq %%rbp, %%rsp");
    x64_emit(ctx, "popq %%rbp");
    x64_emit(ctx, "ret\n");
}

/* Generate instruction */
void x64_generate_instruction(X64Context *ctx, IRInstruction *instr) {
    if (!instr) return;
    
    switch (instr->opcode) {
        case IR_CONST_INT:
            if (instr->dest) {
                x64_emit(ctx, "movq $%ld, %%rax", instr->src1->data.int_val);
            }
            break;
            
        case IR_ADD:
            x64_emit_comment(ctx, "ADD operation");
            x64_emit(ctx, "addq %%rbx, %%rax");
            break;
            
        case IR_SUB:
            x64_emit_comment(ctx, "SUB operation");
            x64_emit(ctx, "subq %%rbx, %%rax");
            break;
            
        case IR_MUL:
            x64_emit_comment(ctx, "MUL operation");
            x64_emit(ctx, "imulq %%rbx, %%rax");
            break;
            
        case IR_DIV:
            x64_emit_comment(ctx, "DIV operation");
            x64_emit(ctx, "cqto");  // Sign extend RAX to RDX:RAX
            x64_emit(ctx, "idivq %%rbx");
            break;
            
        case IR_RETURN:
            if (instr->src1) {
                // Return value already in RAX
            }
            x64_emit(ctx, "jmp %s_return", instr->comment ? instr->comment : "main");
            break;
            
        case IR_PRINT:
            x64_emit_comment(ctx, "Print (placeholder)");
            // TODO: Call printf or custom print function
            break;
            
        case IR_LABEL:
            if (instr->dest && instr->dest->data.label) {
                x64_emit_label(ctx, instr->dest->data.label);
            }
            break;
            
        case IR_JUMP:
            if (instr->dest && instr->dest->data.label) {
                x64_emit(ctx, "jmp %s", instr->dest->data.label);
            }
            break;
            
        case IR_CALL:
            x64_emit_comment(ctx, "Function call");
            if (instr->dest && instr->dest->data.label) {
                x64_emit(ctx, "call %s", instr->dest->data.label);
            }
            break;
            
        default:
            x64_emit_comment(ctx, "Unimplemented opcode");
            break;
    }
}

/* Generate function */
void x64_generate_function(X64Context *ctx, IRFunction *func) {
    if (!func) return;
    
    x64_generate_function_prologue(ctx, func);
    
    // Generate instructions
    IRInstruction *instr = func->instructions;
    while (instr) {
        x64_generate_instruction(ctx, instr);
        instr = instr->next;
    }
    
    x64_generate_function_epilogue(ctx, func);
}

/* Generate complete program */
void x64_generate_program(X64Context *ctx, IRModule *module) {
    if (!module) return;
    
    x64_generate_prologue(ctx);
    
    // Generate all functions
    IRFunction *func = module->functions;
    while (func) {
        x64_generate_function(ctx, func);
        func = func->next;
    }
    
    // Add exit code
    fprintf(ctx->output, "\n# Exit\n");
    fprintf(ctx->output, ".section .note.GNU-stack,\"\",@progbits\n");
}
