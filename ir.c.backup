/* ========================================
   SUB Language - IR Implementation
   Converts AST to intermediate representation
   File: ir.c
   ======================================== */

#define _GNU_SOURCE
#include "ir.h"
#include "sub_compiler.h"
#include "windows_compat.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

/* Create IR module */
IRModule* ir_module_create(void) {
    IRModule *module = calloc(1, sizeof(IRModule));
    module->entry_point = strdup("main");
    return module;
}

/* Free IR module */
void ir_module_free(IRModule *module) {
    if (!module) return;
    
    // Free functions
    IRFunction *func = module->functions;
    while (func) {
        IRFunction *next = func->next;
        
        // Free instructions
        IRInstruction *instr = func->instructions;
        while (instr) {
            IRInstruction *next_instr = instr->next;
            if (instr->dest) free(instr->dest);
            if (instr->src1) free(instr->src1);
            if (instr->src2) free(instr->src2);
            free(instr);
            instr = next_instr;
        }
        
        free(func->name);
        free(func);
        func = next;
    }
    
    // Free string literals
    for (int i = 0; i < module->string_count; i++) {
        free(module->string_literals[i]);
    }
    free(module->string_literals);
    free(module->entry_point);
    free(module);
}

/* Create IR function */
IRFunction* ir_function_create(const char *name, IRType return_type) {
    IRFunction *func = calloc(1, sizeof(IRFunction));
    func->name = strdup(name);
    func->return_type = return_type;
    func->params = NULL;
    func->param_count = 0;
    func->instructions = NULL;
    func->local_count = 0;
    func->reg_count = 0;
    return func;
}

/* Add parameter to function */
void ir_function_add_param(IRFunction *func, IRValue *param) {
    func->params = realloc(func->params, sizeof(IRValue*) * (func->param_count + 1));
    func->params[func->param_count++] = param;
}

/* Add instruction to function */
void ir_function_add_instruction(IRFunction *func, IRInstruction *instr) {
    if (!func->instructions) {
        func->instructions = instr;
    } else {
        IRInstruction *last = func->instructions;
        while (last->next) {
            last = last->next;
        }
        last->next = instr;
    }
}

/* Create IR instruction */
IRInstruction* ir_instruction_create(IROpcode opcode) {
    IRInstruction *instr = calloc(1, sizeof(IRInstruction));
    instr->opcode = opcode;
    return instr;
}

/* Create IR values */
IRValue* ir_value_create_int(int64_t value) {
    IRValue *val = calloc(1, sizeof(IRValue));
    val->type = IR_TYPE_INT;
    val->data.int_val = value;
    return val;
}

IRValue* ir_value_create_float(double value) {
    IRValue *val = calloc(1, sizeof(IRValue));
    val->type = IR_TYPE_FLOAT;
    val->data.float_val = value;
    return val;
}

IRValue* ir_value_create_string(const char *value) {
    IRValue *val = calloc(1, sizeof(IRValue));
    val->type = IR_TYPE_STRING;
    val->data.string_val = strdup(value);
    return val;
}

IRValue* ir_value_create_reg(int reg_num, IRType type) {
    IRValue *val = calloc(1, sizeof(IRValue));
    val->type = type;
    val->data.reg_num = reg_num;
    return val;
}

IRValue* ir_value_create_label(const char *label) {
    IRValue *val = calloc(1, sizeof(IRValue));
    val->type = IR_TYPE_LABEL;
    val->data.label = strdup(label);
    return val;
}

/* Convert AST to IR */
static void ir_generate_from_ast_node(IRFunction *func, ASTNode *node);

IRModule* ir_generate_from_ast(void *ast_root) {
    if (!ast_root) return NULL;
    
    IRModule *module = ir_module_create();
    
    // Create main function
    IRFunction *main_func = ir_function_create("main", IR_TYPE_INT);
    
    // Generate IR from AST
    ASTNode *root = (ASTNode*)ast_root;
    ir_generate_from_ast_node(main_func, root);
    
    // Add return 0 if not present
    IRInstruction *ret_instr = ir_instruction_create(IR_RETURN);
    ret_instr->src1 = ir_value_create_int(0);
    ret_instr->comment = strdup("main");
    ir_function_add_instruction(main_func, ret_instr);
    
    module->functions = main_func;
    
    return module;
}

/* Generate IR from AST node (recursive) */
static void ir_generate_from_ast_node(IRFunction *func, ASTNode *node) {
    if (!node) return;
    
    switch (node->type) {
        case AST_PROGRAM:
            // fprintf(stderr, "DEBUG: Visiting AST_PROGRAM (left=%p, children=%d)\n", node->left, node->child_count);
            // Process linked list of statements (via node->left)
            for (ASTNode *stmt = node->left; stmt != NULL; stmt = stmt->next) {
                ir_generate_from_ast_node(func, stmt);
            }
            // Also check children if any (hybrid approach)
            for (int i = 0; i < node->child_count; i++) {
                ir_generate_from_ast_node(func, node->children[i]);
            }
            break;
            
        case AST_VAR_DECL: {
            // Variable declaration: allocate space
            IRInstruction *alloc = ir_instruction_create(IR_ALLOC);
            alloc->dest = ir_value_create_reg(func->local_count++, IR_TYPE_INT);
            alloc->dest->name = node->value ? strdup(node->value) : NULL;
            ir_function_add_instruction(func, alloc);
            
            // If there's an initializer, store it
            if (node->child_count > 0 || node->right) {
                if (node->child_count > 0)
                    ir_generate_from_ast_node(func, node->children[0]);
                else
                    ir_generate_from_ast_node(func, node->right);
                
                IRInstruction *store = ir_instruction_create(IR_STORE);
                store->dest = alloc->dest;
                ir_function_add_instruction(func, store);
            }
            break;
        }
            
        case AST_CALL_EXPR:
            if (node->value && strcmp(node->value, "print") == 0) {
                // Generate code for arguments
                // Check children array (legacy/multi-arg)
                for (int i = 0; i < node->child_count; i++) {
                    ir_generate_from_ast_node(func, node->children[i]);
                }
                // Check left (enhanced parser single arg)
                if (node->child_count == 0 && node->left) {
                    ir_generate_from_ast_node(func, node->left);
                }
                
                IRInstruction *print = ir_instruction_create(IR_PRINT);
                ir_function_add_instruction(func, print);
            }
            break;
            
        case AST_BINARY_EXPR: {
            // Check for assignment (=)
            if (node->value && strcmp(node->value, "=") == 0) {
                // Handle array element assignment: arr[i] = value
                if (node->left && node->left->type == AST_ARRAY_ACCESS) {
                    ASTNode *array_access = node->left;
                    
                    // Evaluate array expression
                    ir_generate_from_ast_node(func, array_access->left);
                    
                    // Push array pointer to stack
                    IRInstruction *push_arr = ir_instruction_create(IR_PUSH);
                    ir_function_add_instruction(func, push_arr);
                    
                    // Evaluate index expression
                    ir_generate_from_ast_node(func, array_access->right);
                    
                    // Push index to stack
                    IRInstruction *push_idx = ir_instruction_create(IR_PUSH);
                    ir_function_add_instruction(func, push_idx);
                    
                    // Generate right side (value)
                    if (node->right) ir_generate_from_ast_node(func, node->right);
                    
                    // Pop index to RBX
                    IRInstruction *pop_idx = ir_instruction_create(IR_POP);
                    ir_function_add_instruction(func, pop_idx);
                    
                    // Pop array pointer to RCX
                    IRInstruction *pop_arr = ir_instruction_create(IR_POP);
                    ir_function_add_instruction(func, pop_arr);
                    
                    // Store element at arr[index]
                    IRInstruction *store_elem = ir_instruction_create(IR_STORE_ELEM);
                    ir_function_add_instruction(func, store_elem);
                    break;
                }
                
                // Handle simple variable assignment
                if (node->left && node->left->type == AST_IDENTIFIER && node->left->value) {
                    // Find variable register
                     int reg_num = -1;
                    IRInstruction *scan = func->instructions;
                    while (scan) {
                        if ((scan->opcode == IR_ALLOC || scan->opcode == IR_ALLOC_ARRAY) && scan->dest && 
                            scan->dest->name && strcmp(scan->dest->name, node->left->value) == 0) {
                            reg_num = scan->dest->data.reg_num;
                            break;
                        }
                        scan = scan->next;
                    }
                    
                    if (reg_num != -1) {
                        // Generate right side (value)
                        if (node->right) ir_generate_from_ast_node(func, node->right);
                        
                        // Store result to variable
                        IRInstruction *store = ir_instruction_create(IR_STORE);
                        store->dest = ir_value_create_reg(reg_num, IR_TYPE_INT);
                        ir_function_add_instruction(func, store);
                    } else {
                        fprintf(stderr, "Warning: Assignment to undefined variable %s\n", node->left->value);
                    }
                }
                break;
            }

            // Generate left operand
            if (node->left) ir_generate_from_ast_node(func, node->left);
            
            // Push left result (RAX) to stack
            IRInstruction *push = ir_instruction_create(IR_PUSH);
            ir_function_add_instruction(func, push);
            
            // Generate right operand
            if (node->right) ir_generate_from_ast_node(func, node->right);
            
            // Determine operation
            IROpcode op = IR_ADD;
            if (node->value) {
                if (strcmp(node->value, "+") == 0) op = IR_ADD;
                else if (strcmp(node->value, "-") == 0) op = IR_SUB;
                else if (strcmp(node->value, "*") == 0) op = IR_MUL;
                else if (strcmp(node->value, "/") == 0) op = IR_DIV;
                else if (strcmp(node->value, ">") == 0) op = IR_GT;
                else if (strcmp(node->value, "<") == 0) op = IR_LT;
                else if (strcmp(node->value, ">=") == 0) op = IR_GE;
                else if (strcmp(node->value, "<=") == 0) op = IR_LE;
                else if (strcmp(node->value, "==") == 0) op = IR_EQ;
                else if (strcmp(node->value, "!=") == 0) op = IR_NE;
            }
            
            IRInstruction *bin_op = ir_instruction_create(op);
            bin_op->dest = ir_value_create_reg(func->reg_count++, IR_TYPE_INT);
            ir_function_add_instruction(func, bin_op);
            break;
        }
            
        case AST_LITERAL: {
            // Load constant based on type
            if (node->data_type == TYPE_STRING) {
                // String literal
                IRInstruction *load_str = ir_instruction_create(IR_CONST_STRING);
                load_str->dest = ir_value_create_reg(func->reg_count++, IR_TYPE_STRING);
                if (node->value) {
                    load_str->src1 = ir_value_create_string(node->value);
                } else {
                    load_str->src1 = ir_value_create_string("");
                }
                ir_function_add_instruction(func, load_str);
            } else {
                // Integer constant
                IRInstruction *load_const = ir_instruction_create(IR_CONST_INT);
                load_const->dest = ir_value_create_reg(func->reg_count++, IR_TYPE_INT);
                if (node->value) {
                    load_const->src1 = ir_value_create_int(atoi(node->value));
                } else {
                    load_const->src1 = ir_value_create_int(0);
                }
                ir_function_add_instruction(func, load_const);
            }
            break;
        }
            
        case AST_IF_STMT: {
            // Generate condition
            ir_generate_from_ast_node(func, node->condition);
            
            // Assume the result of condition is in the last register
            IRValue *cond_reg = ir_value_create_reg(func->reg_count - 1, IR_TYPE_INT);
            
            // Create labels
            char label_else[32], label_end[32];
            static int label_counter = 0;
            snprintf(label_else, sizeof(label_else), "L_ELSE_%d", label_counter);
            snprintf(label_end, sizeof(label_end), "L_END_%d", label_counter++);
            
            // Jump to else if condition is false (0)
            IRInstruction *jump_if_false = ir_instruction_create(IR_JUMP_IF_NOT);
            jump_if_false->src1 = cond_reg;
            jump_if_false->dest = ir_value_create_label(node->right ? label_else : label_end);
            ir_function_add_instruction(func, jump_if_false);
            
            // Generate 'then' block
            ir_generate_from_ast_node(func, node->body);
            
            // Jump to end
            IRInstruction *jump_end = ir_instruction_create(IR_JUMP);
            jump_end->dest = ir_value_create_label(label_end);
            ir_function_add_instruction(func, jump_end);
            
            // Generate 'else' block if it exists
            if (node->right) {
                IRInstruction *label_instr = ir_instruction_create(IR_LABEL);
                label_instr->dest = ir_value_create_label(label_else);
                ir_function_add_instruction(func, label_instr);
                
                ir_generate_from_ast_node(func, node->right);
            }
            
            // End label
            IRInstruction *label_end_instr = ir_instruction_create(IR_LABEL);
            label_end_instr->dest = ir_value_create_label(label_end);
            ir_function_add_instruction(func, label_end_instr);
            break;
        }
            
        case AST_WHILE_STMT: {
            // Create labels
            char label_start[32], label_end[32];
            static int loop_counter = 0;
            snprintf(label_start, sizeof(label_start), "L_LOOP_%d", loop_counter);
            snprintf(label_end, sizeof(label_end), "L_LOOP_END_%d", loop_counter++);
            
            // Start label
            IRInstruction *label_start_instr = ir_instruction_create(IR_LABEL);
            label_start_instr->dest = ir_value_create_label(label_start);
            ir_function_add_instruction(func, label_start_instr);
            
            // Generate condition
            ir_generate_from_ast_node(func, node->condition);
            IRValue *cond_reg = ir_value_create_reg(func->reg_count - 1, IR_TYPE_INT);
            
            // Jump to end if condition is false
            IRInstruction *jump_if_false = ir_instruction_create(IR_JUMP_IF_NOT);
            jump_if_false->src1 = cond_reg;
            jump_if_false->dest = ir_value_create_label(label_end);
            ir_function_add_instruction(func, jump_if_false);
            
            // Generate body
            ir_generate_from_ast_node(func, node->body);
            
            // Jump back to start
            IRInstruction *jump_loop = ir_instruction_create(IR_JUMP);
            jump_loop->dest = ir_value_create_label(label_start);
            ir_function_add_instruction(func, jump_loop);
            
            // End label
            IRInstruction *label_end_instr = ir_instruction_create(IR_LABEL);
            label_end_instr->dest = ir_value_create_label(label_end);
            ir_function_add_instruction(func, label_end_instr);
            break;
        }

        case AST_BLOCK:
            // Process block statements
            for (ASTNode *stmt = node->body; stmt != NULL; stmt = stmt->next) {
                ir_generate_from_ast_node(func, stmt);
            }
            break;
            
        case AST_ARRAY_LITERAL: {
            // Allocate array with number of elements
            int num_elements = node->child_count;
            
            // Generate IR_ALLOC_ARRAY instruction
            IRInstruction *alloc_array = ir_instruction_create(IR_ALLOC_ARRAY);
            alloc_array->src1 = ir_value_create_int(num_elements);
            alloc_array->dest = ir_value_create_reg(func->reg_count++, IR_TYPE_POINTER);
            ir_function_add_instruction(func, alloc_array);
            
            // Initialize each element
            for (int i = 0; i < num_elements; i++) {
                if (node->children[i]) {
                    // Generate code for element value
                    ir_generate_from_ast_node(func, node->children[i]);
                    
                    // Store element at index i
                    IRInstruction *store_elem = ir_instruction_create(IR_STORE_ELEM);
                    store_elem->src1 = alloc_array->dest; // Array pointer
                    store_elem->src2 = ir_value_create_int(i); // Index
                    ir_function_add_instruction(func, store_elem);
                }
            }
            break;
        }
            
        case AST_ARRAY_ACCESS: {
            // Array access: arr[index]
            // Left side is array, right side is index
            if (node->left && node->right) {
                // Evaluate array expression (should result in array pointer in RAX)
                ir_generate_from_ast_node(func, node->left);
                
                // Push array pointer to stack
                IRInstruction *push_arr = ir_instruction_create(IR_PUSH);
                ir_function_add_instruction(func, push_arr);
                
                // Evaluate index expression
                ir_generate_from_ast_node(func, node->right);
                
                // Pop array pointer back
                IRInstruction *pop_arr = ir_instruction_create(IR_POP);
                ir_function_add_instruction(func, pop_arr);
                
                // Load element
                IRInstruction *load_elem = ir_instruction_create(IR_LOAD_ELEM);
                load_elem->dest = ir_value_create_reg(func->reg_count++, IR_TYPE_INT);
                ir_function_add_instruction(func, load_elem);
            }
            break;
        }

        case AST_IDENTIFIER: {
            // Check if this is an array being accessed (via assignment target)
            int reg_num = -1;
            IRInstruction *scan = func->instructions;
            while (scan) {
                if ((scan->opcode == IR_ALLOC || scan->opcode == IR_ALLOC_ARRAY) && scan->dest && 
                    scan->dest->name && strcmp(scan->dest->name, node->value) == 0) {
                    reg_num = scan->dest->data.reg_num;
                    break;
                }
                scan = scan->next;
            }
            
            if (reg_num != -1) {
                IRInstruction *load = ir_instruction_create(IR_LOAD);
                load->dest = ir_value_create_reg(func->reg_count++, IR_TYPE_INT);
                load->src1 = ir_value_create_reg(reg_num, IR_TYPE_INT);
                ir_function_add_instruction(func, load);
            } else {
                fprintf(stderr, "Warning: Undefined variable %s in IR generation\n", node->value);
            }
            break;
        }

        default:
            // Recurse on children if not handled above
            for (int i = 0; i < node->child_count; i++) {
                ir_generate_from_ast_node(func, node->children[i]);
            }
            break;
    }
}

/* Optimize IR (placeholder) */
void ir_optimize(IRModule *module) {
    // TODO: Implement optimizations
    // - Dead code elimination
    // - Constant folding
    // - Common subexpression elimination
    (void)module;
}

/* Print IR for debugging */
void ir_print(IRModule *module) {
    if (!module) return;
    
    printf("\n=== IR Module ===\n");
    printf("Entry point: %s\n\n", module->entry_point);
    
    IRFunction *func = module->functions;
    while (func) {
        printf("Function: %s\n", func->name);
        printf("  Locals: %d\n", func->local_count);
        printf("  Registers: %d\n", func->reg_count);
        printf("  Instructions:\n");
        
        IRInstruction *instr = func->instructions;
        while (instr) {
            printf("    ");
            switch (instr->opcode) {
                case IR_ADD: printf("ADD"); break;
                case IR_SUB: printf("SUB"); break;
                case IR_MUL: printf("MUL"); break;
                case IR_DIV: printf("DIV"); break;
                case IR_CONST_INT: 
                    printf("CONST_INT %ld", instr->src1->data.int_val); 
                    break;
                case IR_ALLOC:
                    printf("ALLOC %d", instr->dest->data.reg_num);
                    if (instr->dest->name) printf(" (%s)", instr->dest->name);
                    break;
                case IR_ALLOC_ARRAY:
                    printf("ALLOC_ARRAY %d elements", instr->src1 ? instr->src1->data.int_val : 0);
                    break;
                case IR_STORE_ELEM:
                    printf("STORE_ELEM");
                    break;
                case IR_LOAD_ELEM:
                    printf("LOAD_ELEM");
                    break;
                case IR_STORE:
                    printf("STORE %d", instr->dest->data.reg_num);
                    break;
                case IR_LOAD:
                    printf("LOAD %d", instr->src1 ? instr->src1->data.reg_num : -1);
                    break;
                case IR_PUSH: printf("PUSH"); break;
                case IR_POP: printf("POP"); break;
                case IR_PRINT: printf("PRINT"); break;
                case IR_RETURN: printf("RETURN"); break;
                case IR_EQ: printf("EQ"); break;
                case IR_NE: printf("NE"); break;
                case IR_LT: printf("LT"); break;
                case IR_LE: printf("LE"); break;
                case IR_GT: printf("GT"); break;
                case IR_GE: printf("GE"); break;
                case IR_JUMP: printf("JUMP"); break;
                case IR_JUMP_IF_NOT: printf("JUMP_IF_NOT"); break;
                case IR_LABEL: printf("LABEL %s", instr->dest->data.label); break;
                default: printf("UNKNOWN (%d)", instr->opcode); break;
            }
            printf("\n");
            instr = instr->next;
        }
        
        func = func->next;
    }
}
