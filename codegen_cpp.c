/* ========================================
   SUB Language - C++ Code Generator Implementation
   Generates modern C++ code from AST
   File: codegen_cpp.c
   ======================================== */

#define _GNU_SOURCE
#include "codegen_cpp.h"
#include "type_system.h"
#include "windows_compat.h"
#include <stdarg.h>
#include <string.h>

/* String Builder for code generation */
typedef struct {
    char *buffer;
    size_t size;
    size_t capacity;
} StringBuilder;

static StringBuilder* sb_create(void) {
    StringBuilder *sb = malloc(sizeof(StringBuilder));
    if (!sb) return NULL;
    sb->capacity = 16384;
    sb->size = 0;
    sb->buffer = malloc(sb->capacity);
    if (!sb->buffer) {
        free(sb);
        return NULL;
    }
    sb->buffer[0] = '\0';
    return sb;
}

static void sb_free(StringBuilder *sb) {
    if (sb) {
        free(sb->buffer);
        free(sb);
    }
}

static void sb_append(StringBuilder *sb, const char *fmt, ...) {
    if (!sb || !fmt) return;
    
    va_list args;
    va_start(args, fmt);
    
    va_list args_copy;
    va_copy(args_copy, args);
    int needed = vsnprintf(NULL, 0, fmt, args_copy);
    va_end(args_copy);
    
    if (needed < 0) {
        va_end(args);
        return;
    }
    
    while (sb->size + needed + 1 > sb->capacity) {
        sb->capacity *= 2;
        char *new_buffer = realloc(sb->buffer, sb->capacity);
        if (!new_buffer) {
            va_end(args);
            return;
        }
        sb->buffer = new_buffer;
    }
    
    vsnprintf(sb->buffer + sb->size, needed + 1, fmt, args);
    sb->size += needed;
    va_end(args);
}

static char* sb_to_string(StringBuilder *sb) {
    if (!sb) return NULL;
    char *result = strdup(sb->buffer);
    free(sb->buffer);
    free(sb);
    return result;
}

static void indent_code(StringBuilder *sb, int level) {
    for (int i = 0; i < level; i++) {
        sb_append(sb, "    ");
    }
}

/* Helper to extract embedded C++ code from source */
static char* extract_embedded_cpp(const char *source) {
    StringBuilder *sb = sb_create();
    if (!sb) return NULL;
    
    const char *pattern_start = "#embed cpp";
    
    const char *ptr = source;
    while ((ptr = strstr(ptr, pattern_start)) != NULL) {
        ptr = strchr(ptr, '\n');
        if (!ptr) break;
        ptr++;
        
        const char *end = strstr(ptr, "#endembed");
        if (!end) break;
        
        while (ptr < end) {
            sb_append(sb, "%c", *ptr);
            ptr++;
        }
    }
    
    if (sb->size == 0) {
        sb_free(sb);
        return NULL;
    }
    
    return sb_to_string(sb);
}

/* Generate C++ version-specific includes */
static void generate_cpp_includes(StringBuilder *sb, CPPCodegenOptions *options) {
    sb_append(sb, "// Generated by SUB Language Compiler\n");
    
    if (options->use_modules && options->version >= CPP_VER_20) {
        sb_append(sb, "#include <iostream>\n");
        sb_append(sb, "import std;\n");
    } else {
        sb_append(sb, "#include <iostream>\n");
        sb_append(sb, "#include <string>\n");
        sb_append(sb, "#include <vector>\n");
        
        if (options->version >= CPP_VER_17) {
            sb_append(sb, "#include <optional>\n");
            sb_append(sb, "#include <variant>\n");
        }
        
        if (options->version >= CPP_VER_20) {
            sb_append(sb, "#include <concepts>\n");
            sb_append(sb, "#include <span>\n");
        }
    }
    
    sb_append(sb, "\n");
    sb_append(sb, "using namespace std;\n\n");
}

/* Generate C++ expression */
static void generate_expr_cpp(StringBuilder *sb, ASTNode *node, CPPCodegenOptions *options) {
    if (!node) return;
    
    switch (node->type) {
        case AST_LITERAL:
            if (node->data_type == TYPE_STRING && options->use_std_string) {
                sb_append(sb, "std::string(\"%s\")", node->value ? node->value : "");
            } else {
                sb_append(sb, "%s", node->value ? node->value : "nullptr");
            }
            break;
            
        case AST_IDENTIFIER:
            sb_append(sb, "%s", node->value ? node->value : "var");
            break;
            
        case AST_BINARY_EXPR:
            sb_append(sb, "(");
            generate_expr_cpp(sb, node->left, options);
            sb_append(sb, " %s ", node->value ? node->value : "+");
            generate_expr_cpp(sb, node->right, options);
            sb_append(sb, ")");
            break;
            
        case AST_UNARY_EXPR:
            sb_append(sb, "%s", node->value ? node->value : "!");
            if (node->left) {
                generate_expr_cpp(sb, node->left, options);
            }
            break;
            
        case AST_CALL_EXPR: {
            const char *fn = node->value ? node->value : "func";
            if (strcmp(fn, "print") == 0) {
                sb_append(sb, "std::cout << ");
                if (node->left) generate_expr_cpp(sb, node->left, options);
                sb_append(sb, " << std::endl");
            } else {
                sb_append(sb, "%s(", fn);
                if (node->left) generate_expr_cpp(sb, node->left, options);
                sb_append(sb, ")");
            }
            break;
        }
        
        case AST_ARRAY_LITERAL:
            sb_append(sb, "{");
            if (node->children) {
                for (int i = 0; i < node->child_count; i++) {
                    if (i > 0) sb_append(sb, ", ");
                    generate_expr_cpp(sb, node->children[i], options);
                }
            }
            sb_append(sb, "}");
            break;
            
        default:
            break;
    }
}

/* Generate C++ type from DataType */
static const char* get_cpp_type(DataType type, CPPCodegenOptions *options) {
    switch (type) {
        case TYPE_INT:
            return "int";
        case TYPE_FLOAT:
            return options->version >= CPP_VER_20 ? "double" : "double";
        case TYPE_STRING:
            return options->use_std_string ? "std::string" : "const char*";
        case TYPE_BOOL:
            return "bool";
        case TYPE_ARRAY:
            return "std::vector<auto>";
        case TYPE_VOID:
            return "void";
        case TYPE_AUTO:
            return "auto";
        default:
            return options->use_std_string ? "std::string" : "auto";
    }
}

/* Generate C++ node */
static void generate_node_cpp(StringBuilder *sb, ASTNode *node, int indent, CPPCodegenOptions *options) {
    if (!node) return;
    
    switch (node->type) {
        case AST_PROGRAM:
            for (ASTNode *stmt = node->left; stmt != NULL; stmt = stmt->next) {
                generate_node_cpp(sb, stmt, indent, options);
            }
            break;
            
        case AST_VAR_DECL:
            indent_code(sb, indent);
            if (options->use_auto) {
                sb_append(sb, "auto %s", node->value ? node->value : "var");
            } else {
                sb_append(sb, "%s %s", get_cpp_type(node->data_type, options), node->value ? node->value : "var");
            }
            
            if (node->right) {
                sb_append(sb, " = ");
                generate_expr_cpp(sb, node->right, options);
            } else {
                if (options->use_std_string && node->data_type == TYPE_STRING) {
                    sb_append(sb, "(\"\")");
                } else {
                    sb_append(sb, " = {}");
                }
            }
            sb_append(sb, ";\n");
            break;
            
        case AST_CONST_DECL:
            indent_code(sb, indent);
            if (options->version >= CPP_VER_17 && options->use_constexpr) {
                sb_append(sb, "constexpr ");
            } else {
                sb_append(sb, "const ");
            }
            if (options->use_auto) {
                sb_append(sb, "auto %s", node->value ? node->value : "var");
            } else {
                sb_append(sb, "%s %s", get_cpp_type(node->data_type, options), node->value ? node->value : "var");
            }
            sb_append(sb, " = ");
            generate_expr_cpp(sb, node->right, options);
            sb_append(sb, ";\n");
            break;
            
        case AST_FUNCTION_DECL: {
            const char *func_name = node->value ? node->value : "func";
            const char *return_type = node->data_type != TYPE_VOID ? get_cpp_type(node->data_type, options) : "void";
            
            if (options->use_concepts && options->version >= CPP_VER_20) {
                sb_append(sb, "\ntemplate<typename T>\n");
                sb_append(sb, "concept Printable = requires(T t) {\n");
                sb_append(sb, "    { std::cout << t } -> std::same_as<std::ostream&>;\n");
                sb_append(sb, "};\n\n");
            }
            
            sb_append(sb, "\n%s %s()", return_type, func_name);
            
            sb_append(sb, " {\n");
            if (node->body) {
                generate_node_cpp(sb, node->body, indent + 1, options);
            }
            sb_append(sb, "}\n");
            break;
        }
        
        case AST_ARROW_FUNCTION:
            if (options->version >= CPP_VER_11) {
                indent_code(sb, indent);
                sb_append(sb, "auto %s = []()", node->value ? node->value : "lambda");
                sb_append(sb, " {\n");
                if (node->body) {
                    generate_node_cpp(sb, node->body, indent + 1, options);
                }
                indent_code(sb, indent);
                sb_append(sb, "};\n");
            }
            break;
            
        case AST_FOR_STMT:
            indent_code(sb, indent);
            if (options->use_range_based_for) {
                sb_append(sb, "for (auto %s : ", node->value ? node->value : "item");
                if (node->right) generate_expr_cpp(sb, node->right, options);
                else sb_append(sb, "std::vector<int>{0,1,2,3,4,5,6,7,8,9}");
                sb_append(sb, ") {\n");
            } else {
                sb_append(sb, "for (int %s = 0; %s < 10; %s++) {\n",
                         node->value ? node->value : "i",
                         node->value ? node->value : "i",
                         node->value ? node->value : "i");
            }
            if (node->body) {
                generate_node_cpp(sb, node->body, indent + 1, options);
            }
            indent_code(sb, indent);
            sb_append(sb, "}\n");
            break;
            
        case AST_WHILE_STMT:
            indent_code(sb, indent);
            sb_append(sb, "while (");
            if (node->condition) generate_expr_cpp(sb, node->condition, options);
            else sb_append(sb, "true");
            sb_append(sb, ") {\n");
            if (node->body) {
                generate_node_cpp(sb, node->body, indent + 1, options);
            }
            indent_code(sb, indent);
            sb_append(sb, "}\n");
            break;
            
        case AST_IF_STMT:
            indent_code(sb, indent);
            sb_append(sb, "if (");
            if (node->condition) generate_expr_cpp(sb, node->condition, options);
            else sb_append(sb, "true");
            sb_append(sb, ") {\n");
            if (node->body) {
                generate_node_cpp(sb, node->body, indent + 1, options);
            }
            if (node->right) {
                indent_code(sb, indent);
                sb_append(sb, "} else {\n");
                generate_node_cpp(sb, node->right, indent + 1, options);
            }
            indent_code(sb, indent);
            sb_append(sb, "}\n");
            break;
            
        case AST_RETURN_STMT:
            indent_code(sb, indent);
            sb_append(sb, "return");
            if (node->left) {
                sb_append(sb, " ");
                generate_expr_cpp(sb, node->left, options);
            }
            sb_append(sb, ";\n");
            break;
            
        case AST_BREAK_STMT:
            indent_code(sb, indent);
            sb_append(sb, "break;\n");
            break;
            
        case AST_CONTINUE_STMT:
            indent_code(sb, indent);
            sb_append(sb, "continue;\n");
            break;
            
        case AST_ASSIGN_STMT:
            indent_code(sb, indent);
            if (node->left) generate_expr_cpp(sb, node->left, options);
            sb_append(sb, " = ");
            if (node->right) generate_expr_cpp(sb, node->right, options);
            sb_append(sb, ";\n");
            break;
            
        case AST_CALL_EXPR:
            indent_code(sb, indent);
            generate_expr_cpp(sb, node, options);
            sb_append(sb, ";\n");
            break;
            
        case AST_BLOCK:
            for (ASTNode *s = node->body; s != NULL; s = s->next) {
                generate_node_cpp(sb, s, indent, options);
            }
            break;
            
        default:
            break;
    }
}

/* Main C++ code generation function */
char* codegen_cpp(ASTNode *ast, const char *source, CPPCodegenOptions *options) {
    CPPCodegenOptions default_options;
    if (!options) {
        codegen_cpp_get_default_options(CPP_VER_17, &default_options);
        options = &default_options;
    }
    
    char *embedded = extract_embedded_cpp(source);
    if (embedded) {
        StringBuilder *sb = sb_create();
        sb_append(sb, "// Generated by SUB Language Compiler\n\n");
        sb_append(sb, "%s\n", embedded);
        free(embedded);
        return sb_to_string(sb);
    }
    
    StringBuilder *sb = sb_create();
    if (!sb) return NULL;
    
    generate_cpp_includes(sb, options);
    
    generate_node_cpp(sb, ast, 0, options);
    
    sb_append(sb, "\nint main() {\n");
    sb_append(sb, "    return 0;\n");
    sb_append(sb, "}\n");
    
    return sb_to_string(sb);
}

/* Get default options for C++ version */
void codegen_cpp_get_default_options(CPPVersion version, CPPCodegenOptions *options) {
    if (!options) return;
    
    options->version = version;
    options->use_std_string = true;
    options->use_auto = (version >= CPP_VER_11);
    options->use_concepts = (version >= CPP_VER_20);
    options->use_modules = (version >= CPP_VER_20);
    options->use_range_based_for = (version >= CPP_VER_11);
    options->use_constexpr = (version >= CPP_VER_11);
}

/* Convert C++ version enum to string */
const char* codegen_cpp_version_to_string(CPPVersion version) {
    switch (version) {
        case CPP_VER_11: return "C++11";
        case CPP_VER_14: return "C++14";
        case CPP_VER_17: return "C++17";
        case CPP_VER_20: return "C++20";
        case CPP_VER_23: return "C++23";
        default: return "C++17";
    }
}

/* Parse C++ version string to enum */
CPPVersion codegen_cpp_parse_version(const char *version_str) {
    if (!version_str) return CPP_VER_17;
    
    if (strcasecmp(version_str, "cpp11") == 0 ||
        strcasecmp(version_str, "c++11") == 0) return CPP_VER_11;
    
    if (strcasecmp(version_str, "cpp14") == 0 ||
        strcasecmp(version_str, "c++14") == 0) return CPP_VER_14;
    
    if (strcasecmp(version_str, "cpp17") == 0 ||
        strcasecmp(version_str, "c++17") == 0) return CPP_VER_17;
    
    if (strcasecmp(version_str, "cpp20") == 0 ||
        strcasecmp(version_str, "c++20") == 0) return CPP_VER_20;
    
    if (strcasecmp(version_str, "cpp23") == 0 ||
        strcasecmp(version_str, "c++23") == 0) return CPP_VER_23;
    
    if (strcasecmp(version_str, "cpp") == 0 ||
        strcasecmp(version_str, "c++") == 0) return CPP_VER_17;
    
    return CPP_VER_17;
}
