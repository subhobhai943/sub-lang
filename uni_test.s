# Generated by SUB Native Compiler
# Architecture: x86-64

.section .rodata
.LC0:
    .string "%ld\n"
.section .data
.section .text
.global main

main:
    # Function prologue
    pushq %rbp
    movq %rsp, %rbp
    subq $32, %rsp
    movq $123456789, %rax
    # Print integer
    movq %rax, %rsi
    leaq .LC0(%rip), %rdi
    xorq %rax, %rax
    call printf@PLT
    # Alloc variable (noop, stack reserved)
    movq $10, %rax
    # Store variable
    movq %rax, -8(%rbp)
    # Alloc variable (noop, stack reserved)
    movq $20, %rax
    # Store variable
    movq %rax, -16(%rbp)
    # Alloc variable (noop, stack reserved)
    # Load variable
    movq -8(%rbp), %rax
    pushq %rax
    # Load variable
    movq -16(%rbp), %rax
    # ADD operation
    popq %rbx
    addq %rbx, %rax
    # Store variable
    movq %rax, -24(%rbp)
    # Load variable
    movq -24(%rbp), %rax
    # Print integer
    movq %rax, %rsi
    leaq .LC0(%rip), %rdi
    xorq %rax, %rax
    call printf@PLT
    # Load variable
    movq -24(%rbp), %rax
    pushq %rax
    movq $25, %rax
    # Comparison
    movq %rax, %rbx
    popq %rax
    cmpq %rbx, %rax
    movq $0, %rax
    setg %al
    # Jump if false (0)
    cmpq $0, %rax
    je L_ELSE_0
    movq $1, %rax
    # Print integer
    movq %rax, %rsi
    leaq .LC0(%rip), %rdi
    xorq %rax, %rax
    call printf@PLT
    jmp L_END_0
L_ELSE_0:
    movq $0, %rax
    # Print integer
    movq %rax, %rsi
    leaq .LC0(%rip), %rdi
    xorq %rax, %rax
    call printf@PLT
L_END_0:
    # Alloc variable (noop, stack reserved)
    movq $5, %rax
    # Store variable
    movq %rax, -32(%rbp)
L_LOOP_0:
    # Load variable
    movq -32(%rbp), %rax
    pushq %rax
    movq $0, %rax
    # Comparison
    movq %rax, %rbx
    popq %rax
    cmpq %rbx, %rax
    movq $0, %rax
    setg %al
    # Jump if false (0)
    cmpq $0, %rax
    je L_LOOP_END_0
    # Load variable
    movq -32(%rbp), %rax
    # Print integer
    movq %rax, %rsi
    leaq .LC0(%rip), %rdi
    xorq %rax, %rax
    call printf@PLT
    # Load variable
    movq -32(%rbp), %rax
    pushq %rax
    movq $1, %rax
    # SUB operation
    movq %rax, %rbx
    popq %rax
    subq %rbx, %rax
    # Store variable
    movq %rax, -32(%rbp)
    jmp L_LOOP_0
L_LOOP_END_0:
    movq $999, %rax
    # Print integer
    movq %rax, %rsi
    leaq .LC0(%rip), %rdi
    xorq %rax, %rax
    call printf@PLT
    movq $0, %rax
    jmp main_return
    # Function epilogue
main_return:
    movq %rbp, %rsp
    popq %rbp
    ret


# Exit
.section .note.GNU-stack,"",@progbits
