# ==========================================
# SUB Standard Library - Collections Module
# File: stdlib/collections.sb
# Data structures and collection utilities
# ==========================================

# Array operations
#func array_new(size, initial_value) -> array {
    #var arr = []
    #for i in range(size) {
        arr.append(initial_value)
    }
    #return arr
}

#func array_append(arr, value) {
    arr[len(arr)] = value
}

#func array_insert(arr, index, value) {
    #for i in range(len(arr), index, -1) {
        arr[i] = arr[i - 1]
    }
    arr[index] = value
}

#func array_remove(arr, index) {
    #for i in range(index, len(arr) - 1) {
        arr[i] = arr[i + 1]
    }
    # Resize array (implementation dependent)
}

#func array_pop(arr) {
    #var last = arr[len(arr) - 1]
    # Resize array
    #return last
}

#func array_clear(arr) {
    #while len(arr) > 0 {
        array_pop(arr)
    }
}

# Array searching
#func array_find(arr, value) -> int {
    #for i in range(len(arr)) {
        #if arr[i] == value {
            #return i
        }
    }
    #return -1
}

#func array_contains(arr, value) -> bool {
    #return array_find(arr, value) != -1
}

#func array_count(arr, value) -> int {
    #var count = 0
    #for item in arr {
        #if item == value {
            count = count + 1
        }
    }
    #return count
}

# Array transformations
#func array_map(arr, func) -> array {
    #var result = []
    #for item in arr {
        result.append(func(item))
    }
    #return result
}

#func array_filter(arr, predicate) -> array {
    #var result = []
    #for item in arr {
        #if predicate(item) {
            result.append(item)
        }
    }
    #return result
}

#func array_reduce(arr, func, initial) {
    #var acc = initial
    #for item in arr {
        acc = func(acc, item)
    }
    #return acc
}

# Sorting
#func array_sort(arr) -> array {
    # Bubble sort (simple implementation)
    #var n = len(arr)
    #for i in range(n) {
        #for j in range(0, n - i - 1) {
            #if arr[j] > arr[j + 1] {
                #var temp = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = temp
            }
        }
    }
    #return arr
}

#func array_reverse(arr) -> array {
    #var left = 0
    #var right = len(arr) - 1

    #while left < right {
        #var temp = arr[left]
        arr[left] = arr[right]
        arr[right] = temp
        left = left + 1
        right = right - 1
    }
    #return arr
}

# Array statistics
#func array_min(arr) {
    #if len(arr) == 0 {
        #return null
    }

    #var min_val = arr[0]
    #for i in range(1, len(arr)) {
        #if arr[i] < min_val {
            min_val = arr[i]
        }
    }
    #return min_val
}

#func array_max(arr) {
    #if len(arr) == 0 {
        #return null
    }

    #var max_val = arr[0]
    #for i in range(1, len(arr)) {
        #if arr[i] > max_val {
            max_val = arr[i]
        }
    }
    #return max_val
}

# Set operations (using arrays)
#func set_union(set1, set2) -> array {
    #var result = []

    #for item in set1 {
        #if !array_contains(result, item) {
            result.append(item)
        }
    }

    #for item in set2 {
        #if !array_contains(result, item) {
            result.append(item)
        }
    }

    #return result
}

#func set_intersection(set1, set2) -> array {
    #var result = []

    #for item in set1 {
        #if array_contains(set2, item) && !array_contains(result, item) {
            result.append(item)
        }
    }

    #return result
}

#func set_difference(set1, set2) -> array {
    #var result = []

    #for item in set1 {
        #if !array_contains(set2, item) {
            result.append(item)
        }
    }

    #return result
}

# Stack (LIFO)
#func stack_new() -> array {
    #return []
}

#func stack_push(stack, value) {
    array_append(stack, value)
}

#func stack_pop(stack) {
    #if len(stack) == 0 {
        #return null
    }
    #return array_pop(stack)
}

#func stack_peek(stack) {
    #if len(stack) == 0 {
        #return null
    }
    #return stack[len(stack) - 1]
}

#func stack_is_empty(stack) -> bool {
    #return len(stack) == 0
}

# Queue (FIFO)
#func queue_new() -> array {
    #return []
}

#func queue_enqueue(queue, value) {
    array_append(queue, value)
}

#func queue_dequeue(queue) {
    #if len(queue) == 0 {
        #return null
    }
    #var front = queue[0]
    array_remove(queue, 0)
    #return front
}

#func queue_front(queue) {
    #if len(queue) == 0 {
        #return null
    }
    #return queue[0]
}

#func queue_is_empty(queue) -> bool {
    #return len(queue) == 0
}

# Hash Map (simple implementation using arrays)
#func map_new() -> map {
    #return {}
}

#func map_set(map, key, value) {
    map[key] = value
}

#func map_get(map, key) {
    #return map[key]
}

#func map_has(map, key) -> bool {
    #return key in map
}

#func map_delete(map, key) {
    #delete map[key]
}

#func map_keys(map) -> array {
    #return keys(map)
}

#func map_values(map) -> array {
    #return values(map)
}

#func map_size(map) -> int {
    #return len(map_keys(map))
}
